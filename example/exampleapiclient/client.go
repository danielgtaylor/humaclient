// Code generated by humaclient. DO NOT EDIT.

package exampleapiclient

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"iter"
	"net/http"
	"net/url"
	"strings"
)

// ErrorDetail represents the ErrorDetail schema
type ErrorDetail struct {
	Location string `json:"location,omitempty" doc:"Where the error occurred, e.g. 'body.items[3].tags' or 'path.thing-id'"`
	Message  string `json:"message,omitempty" doc:"Error message text"`
	Value    any    `json:"value,omitempty" doc:"The value at the given location"`
}

// ErrorModel represents the ErrorModel schema
type ErrorModel struct {
	Detail   string         `json:"detail,omitempty" doc:"A human-readable explanation specific to this occurrence of the problem." example:"Property foo is required but is missing."`
	Errors   []*ErrorDetail `json:"errors,omitempty" doc:"Optional list of individual error details"`
	Instance string         `json:"instance,omitempty" doc:"A URI reference that identifies the specific occurrence of the problem." format:"uri" example:"https://example.com/error-log/abc123"`
	Status   int64          `json:"status,omitempty" doc:"HTTP status code" format:"int64" example:"400"`
	Title    string         `json:"title,omitempty" doc:"A short, human-readable summary of the problem type. This value should not change between occurrences of the error." example:"Bad Request"`
	Type     string         `json:"type,omitempty" doc:"A URI reference to human-readable documentation for the error." default:"about:blank" format:"uri" example:"https://example.com/errors/example"`
}

// ListThingsResponseBody represents the ListThingsResponseBody schema
type ListThingsResponseBody struct {
	Items []*Thing `json:"items" doc:"The list of things"`
	Next  string   `json:"next,omitempty" doc:"URL for the next page of results"`
	Total int64    `json:"total" doc:"Total number of things" format:"int64"`
}

// Thing represents the Thing schema
type Thing struct {
	DeprecatedField string `json:"deprecatedField" doc:"This field is deprecated" deprecated:"true"`
	ID              string `json:"id" doc:"The unique identifier for the thing" minLength:"8" pattern:"^[a-z0-9_-]+$"`
	Name            string `json:"name" doc:"The name of the thing" minLength:"3" example:"My Thing"`
	ReadOnlyID      string `json:"readOnlyId" doc:"Read-only identifier" readOnly:"true"`
	WriteOnlyToken  string `json:"writeOnlyToken" doc:"Write-only authentication token" writeOnly:"true"`
}

// Option is a functional option for customizing requests
type Option func(*RequestOptions)

// OptionsApplier is an interface for operation-specific options
type OptionsApplier interface {
	Apply(*RequestOptions)
}

// RequestOptions contains optional parameters for API requests
type RequestOptions struct {
	CustomHeaders map[string]string
	CustomQuery   map[string]string
	Body          any
}

// applyQueryParams applies custom query parameters to a URL
func (r *RequestOptions) applyQueryParams(u *url.URL) {
	if len(r.CustomQuery) > 0 {
		q := u.Query()
		for key, value := range r.CustomQuery {
			q.Set(key, value)
		}
		u.RawQuery = q.Encode()
	}
}

// applyHeaders applies custom headers to an HTTP request
func (r *RequestOptions) applyHeaders(req *http.Request) {
	for key, value := range r.CustomHeaders {
		req.Header.Set(key, value)
	}
}

// Functional options for customizing requests
func WithHeader(key, value string) Option {
	return func(opts *RequestOptions) {
		if opts.CustomHeaders == nil {
			opts.CustomHeaders = make(map[string]string)
		}
		opts.CustomHeaders[key] = value
	}
}

func WithQuery(key, value string) Option {
	return func(opts *RequestOptions) {
		if opts.CustomQuery == nil {
			opts.CustomQuery = make(map[string]string)
		}
		opts.CustomQuery[key] = value
	}
}

func WithBody(body any) Option {
	return func(opts *RequestOptions) {
		opts.Body = body
	}
}

// WithOptions applies operation-specific optional parameters
func WithOptions(applier OptionsApplier) Option {
	return func(opts *RequestOptions) {
		applier.Apply(opts)
	}
}

// ListThingsOptions contains optional parameters for ListThings
type ListThingsOptions struct {
	Limit  int64  `json:"limit,omitempty"`
	Cursor string `json:"cursor,omitempty"`
}

// Apply implements OptionsApplier for ListThingsOptions
func (o ListThingsOptions) Apply(opts *RequestOptions) {
	if o.Limit != 0 {
		if opts.CustomQuery == nil {
			opts.CustomQuery = make(map[string]string)
		}
		opts.CustomQuery["limit"] = fmt.Sprintf("%v", o.Limit)
	}
	if o.Cursor != "" {
		if opts.CustomQuery == nil {
			opts.CustomQuery = make(map[string]string)
		}
		opts.CustomQuery["cursor"] = o.Cursor
	}
}

// ExampleAPIClient defines the interface for the API client
type ExampleAPIClient interface {
	ListThings(ctx context.Context, opts ...Option) (*http.Response, ListThingsResponseBody, error)
	ListThingsPaginator(ctx context.Context, opts ...Option) iter.Seq2[*Thing, error]
	GetThingsByID(ctx context.Context, id string, opts ...Option) (*http.Response, Thing, error)
	Follow(ctx context.Context, link string, result any, opts ...Option) (*http.Response, error)
}

// ExampleAPIClientImpl implements the ExampleAPIClient interface
type ExampleAPIClientImpl struct {
	baseURL    string
	httpClient *http.Client
}

// New creates a new ExampleAPIClient with default HTTP client
func New(baseURL string) ExampleAPIClient {
	return NewWithClient(baseURL, nil)
}

// NewWithClient creates a new ExampleAPIClient with custom base URL and HTTP client
func NewWithClient(baseURL string, client *http.Client) ExampleAPIClient {
	if client == nil {
		client = &http.Client{}
	}
	return &ExampleAPIClientImpl{
		baseURL:    baseURL,
		httpClient: client,
	}
}

// ListThings calls the GET /things endpoint
func (c *ExampleAPIClientImpl) ListThings(ctx context.Context, opts ...Option) (*http.Response, ListThingsResponseBody, error) {
	// Apply options
	reqOpts := &RequestOptions{}
	for _, opt := range opts {
		opt(reqOpts)
	}

	// Build URL with path parameters
	pathTemplate := "/things"

	u, err := url.Parse(c.baseURL + pathTemplate)
	if err != nil {
		return nil, ListThingsResponseBody{}, fmt.Errorf("invalid URL: %w", err)
	}

	// Apply query parameters
	reqOpts.applyQueryParams(u)

	// Prepare request body
	var reqBody io.Reader

	// Create request
	req, err := http.NewRequestWithContext(ctx, "GET", u.String(), reqBody)
	if err != nil {
		return nil, ListThingsResponseBody{}, fmt.Errorf("failed to create request: %w", err)
	}

	// Set content type and apply custom headers
	reqOpts.applyHeaders(req)

	// Execute request
	resp, err := c.httpClient.Do(req)
	if err != nil {
		return nil, ListThingsResponseBody{}, fmt.Errorf("request failed: %w", err)
	}
	defer resp.Body.Close()

	// Handle error responses
	if resp.StatusCode >= 400 {
		body, _ := io.ReadAll(resp.Body)
		return resp, ListThingsResponseBody{}, fmt.Errorf("API error %d: %s", resp.StatusCode, string(body))
	}
	// Parse response body
	var result ListThingsResponseBody
	if err := json.NewDecoder(resp.Body).Decode(&result); err != nil {
		return resp, ListThingsResponseBody{}, fmt.Errorf("failed to decode response: %w", err)
	}

	return resp, result, nil
}

// GetThingsByID calls the GET /things/{id} endpoint
func (c *ExampleAPIClientImpl) GetThingsByID(ctx context.Context, id string, opts ...Option) (*http.Response, Thing, error) {
	// Apply options
	reqOpts := &RequestOptions{}
	for _, opt := range opts {
		opt(reqOpts)
	}

	// Build URL with path parameters
	pathTemplate := "/things/{id}"
	pathTemplate = strings.ReplaceAll(pathTemplate, "{id}", url.PathEscape(id))

	u, err := url.Parse(c.baseURL + pathTemplate)
	if err != nil {
		return nil, Thing{}, fmt.Errorf("invalid URL: %w", err)
	}

	// Apply query parameters
	reqOpts.applyQueryParams(u)

	// Prepare request body
	var reqBody io.Reader

	// Create request
	req, err := http.NewRequestWithContext(ctx, "GET", u.String(), reqBody)
	if err != nil {
		return nil, Thing{}, fmt.Errorf("failed to create request: %w", err)
	}

	// Set content type and apply custom headers
	reqOpts.applyHeaders(req)

	// Execute request
	resp, err := c.httpClient.Do(req)
	if err != nil {
		return nil, Thing{}, fmt.Errorf("request failed: %w", err)
	}
	defer resp.Body.Close()

	// Handle error responses
	if resp.StatusCode >= 400 {
		body, _ := io.ReadAll(resp.Body)
		return resp, Thing{}, fmt.Errorf("API error %d: %s", resp.StatusCode, string(body))
	}
	// Parse response body
	var result Thing
	if err := json.NewDecoder(resp.Body).Decode(&result); err != nil {
		return resp, Thing{}, fmt.Errorf("failed to decode response: %w", err)
	}

	return resp, result, nil
}

// Follow follows a link to retrieve a related resource
func (c *ExampleAPIClientImpl) Follow(ctx context.Context, link string, result any, opts ...Option) (*http.Response, error) {
	// Apply options
	reqOpts := &RequestOptions{}
	for _, opt := range opts {
		opt(reqOpts)
	}

	// Parse the link URL
	u, err := url.Parse(link)
	if err != nil {
		return nil, fmt.Errorf("invalid link URL: %w", err)
	}

	// Apply query parameters
	reqOpts.applyQueryParams(u)

	// Prepare request body if provided
	var reqBody io.Reader
	if reqOpts.Body != nil {
		jsonData, err := json.Marshal(reqOpts.Body)
		if err != nil {
			return nil, fmt.Errorf("failed to marshal request body: %w", err)
		}
		reqBody = bytes.NewReader(jsonData)
	}

	// Create request (assume GET unless body is provided)
	method := "GET"
	if reqBody != nil {
		method = "POST"
	}

	req, err := http.NewRequestWithContext(ctx, method, u.String(), reqBody)
	if err != nil {
		return nil, fmt.Errorf("failed to create request: %w", err)
	}

	// Set content type and apply custom headers
	if reqBody != nil {
		req.Header.Set("Content-Type", "application/json")
	}
	reqOpts.applyHeaders(req)

	// Execute request
	resp, err := c.httpClient.Do(req)
	if err != nil {
		return nil, fmt.Errorf("request failed: %w", err)
	}
	defer resp.Body.Close()

	// Handle error responses
	if resp.StatusCode >= 400 {
		body, _ := io.ReadAll(resp.Body)
		return resp, fmt.Errorf("API error %d: %s", resp.StatusCode, string(body))
	}

	// Parse response body into provided result type
	if err := json.NewDecoder(resp.Body).Decode(result); err != nil {
		return resp, fmt.Errorf("failed to decode response: %w", err)
	}

	return resp, nil
}

// ListThingsPaginator returns an iterator that fetches all pages of ListThings results
func (c *ExampleAPIClientImpl) ListThingsPaginator(ctx context.Context, opts ...Option) iter.Seq2[*Thing, error] {
	return func(yield func(*Thing, error) bool) {
		// Start with the first page
		resp, result, err := c.ListThings(ctx, opts...)
		if err != nil {
			var zero *Thing
			if !yield(zero, err) {
				return
			}
			return
		}

		// Yield all items from the first page
		for _, item := range result.Items {
			if !yield(item, nil) {
				return
			}
		}

		// Follow pagination links
		for {
			nextURL := ""
			// Check for Link header with rel=next
			linkHeader := resp.Header.Get("Link")
			if linkHeader != "" {
				nextURL = parseLinkHeader(linkHeader, "next")
			}

			// Fall back to body field for next page URL
			if nextURL == "" && result.Next != "" {
				nextURL = result.Next
			}

			if nextURL == "" {
				break
			}

			// Fetch next page using Follow method
			var nextResult ListThingsResponseBody
			resp, err = c.Follow(ctx, nextURL, &nextResult, opts...)
			if err != nil {
				var zero *Thing
				if !yield(zero, err) {
					return
				}
				return
			}

			// Yield all items from this page
			for _, item := range nextResult.Items {
				if !yield(item, nil) {
					return
				}
			}

			result = nextResult
		}
	}
}

// parseLinkHeader parses a Link header and returns the URL for the specified relation
func parseLinkHeader(linkHeader, rel string) string {
	// Simple parser for Link header format: <url>; rel="next", <url2>; rel="prev"
	links := strings.Split(linkHeader, ",")
	for _, link := range links {
		link = strings.TrimSpace(link)
		parts := strings.Split(link, ";")
		if len(parts) < 2 {
			continue
		}

		url := strings.Trim(strings.TrimSpace(parts[0]), "<>")

		for _, param := range parts[1:] {
			param = strings.TrimSpace(param)
			if strings.Contains(param, "rel=") {
				// Extract rel value (handle both quoted and unquoted)
				relValue := strings.TrimPrefix(param, "rel=")
				relValue = strings.Trim(relValue, "\"'")
				if relValue == rel {
					return url
				}
			}
		}
	}
	return ""
}
